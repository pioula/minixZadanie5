diff -rupNEZbB old/usr/src/minix/include/minix/callnr.h src/usr/src/minix/include/minix/callnr.h
--- old/usr/src/minix/include/minix/callnr.h	2022-06-07 20:52:56.517947606 +0200
+++ src/usr/src/minix/include/minix/callnr.h	2022-06-07 21:35:26.285761691 +0200
@@ -118,7 +118,8 @@
 #define VFS_COPYFD		(VFS_BASE + 46)
 #define VFS_CHECKPERMS		(VFS_BASE + 47)
 #define VFS_GETSYSINFO		(VFS_BASE + 48)
+#define VFS_NOTIFY		(VFS_BASE + 49)
 
-#define NR_VFS_CALLS		49	/* highest number from base plus one */
+#define NR_VFS_CALLS		50	/* highest number from base plus one */
 
 #endif /* !_MINIX_CALLNR_H */
diff -rupNEZbB old/usr/src/minix/include/minix/ipc.h src/usr/src/minix/include/minix/ipc.h
--- old/usr/src/minix/include/minix/ipc.h	2022-06-07 20:53:17.386307796 +0200
+++ src/usr/src/minix/include/minix/ipc.h	2022-06-07 21:35:32.561969216 +0200
@@ -842,6 +842,14 @@ typedef struct {
 _ASSERT_MSG_SIZE(mess_lc_vfs_umount);
 
 typedef struct {
+	int fd;
+	int event;
+
+	uint8_t data[48];
+} mess_lc_vfs_notify;
+_ASSERT_MSG_SIZE(mess_lc_vfs_notify);
+
+typedef struct {
 	void		*addr;
 	uint8_t		padding[52];
 } mess_lc_vm_brk;
@@ -2121,6 +2129,7 @@ typedef struct {
 		mess_lc_vfs_truncate	m_lc_vfs_truncate;
 		mess_lc_vfs_umask	m_lc_vfs_umask;
 		mess_lc_vfs_umount	m_lc_vfs_umount;
+		mess_lc_vfs_notify	m_lc_vfs_notify;
 		mess_lc_vm_brk		m_lc_vm_brk;
 		mess_lc_vm_getphys	m_lc_vm_getphys;
 		mess_lc_vm_rusage	m_lc_vm_rusage;
diff -rupNEZbB old/usr/src/minix/servers/vfs/const.h src/usr/src/minix/servers/vfs/const.h
--- old/usr/src/minix/servers/vfs/const.h	2022-06-07 20:56:52.192042193 +0200
+++ src/usr/src/minix/servers/vfs/const.h	2022-06-14 11:34:31.602984243 +0200
@@ -7,6 +7,7 @@
 #define NR_MNTS           16 	/* # slots in mount table */
 #define NR_VNODES       1024	/* # slots in vnode table */
 #define NR_WTHREADS	   9	/* # slots in worker thread table */
+#define NR_NOTIFY          8	/* # slots in notify table */
 
 #define NR_NONEDEVS	NR_MNTS	/* # slots in nonedev bitmap */
 
@@ -22,6 +23,7 @@
 #define FP_BLOCKED_ON_SELECT	4 /* susp'd on select */
 #define FP_BLOCKED_ON_OTHER	5 /* blocked on other process, check
 				     fp_task to find out */
+#define FP_BLOCKED_ON_NOTIFY_OPEN	6 /* blocked on open notify */
 
 /* test if the process is blocked on something */
 #define fp_is_blocked(fp)	((fp)->fp_blocked_on != FP_BLOCKED_ON_NONE)
diff -rupNEZbB old/usr/src/minix/servers/vfs/glo.h src/usr/src/minix/servers/vfs/glo.h
--- old/usr/src/minix/servers/vfs/glo.h	2022-06-14 19:22:30.533121621 +0200
+++ src/usr/src/minix/servers/vfs/glo.h	2022-06-14 19:24:05.569256614 +0200
@@ -17,6 +17,7 @@ EXTERN int reviving;		/* number of pipe
 EXTERN int pending;
 EXTERN int sending;
 EXTERN int verbose;
+EXTERN int listeners;       /* number of notify listeners */
 
 EXTERN dev_t ROOT_DEV;		/* device number of the root device */
 EXTERN int ROOT_FS_E;           /* kernel endpoint of the root FS proc */
diff -rupNEZbB old/usr/src/minix/servers/vfs/Makefile src/usr/src/minix/servers/vfs/Makefile
--- old/usr/src/minix/servers/vfs/Makefile	2022-06-07 20:56:45.419819611 +0200
+++ src/usr/src/minix/servers/vfs/Makefile	2022-06-07 21:36:45.384387067 +0200
@@ -7,7 +7,8 @@ SRCS=	main.c open.c read.c write.c pipe.
 	filedes.c stadir.c protect.c time.c \
 	lock.c misc.c utility.c select.c table.c \
 	vnode.c vmnt.c request.c \
-	tll.c comm.c worker.c coredump.c
+	tll.c comm.c worker.c coredump.c \
+	notify.c
 
 .if ${MKCOVERAGE} != "no"
 SRCS+=  gcov.c
diff -rupNEZbB old/usr/src/minix/servers/vfs/notify.c src/usr/src/minix/servers/vfs/notify.c
--- old/usr/src/minix/servers/vfs/notify.c	1970-01-01 01:00:00.000000000 +0100
+++ src/usr/src/minix/servers/vfs/notify.c	2022-06-14 19:26:57.346805562 +0200
@@ -0,0 +1,38 @@
+#include <fcntl.h>
+#include <errno.h>
+
+#include "fs.h"
+#include "const.h"
+#include "file.h"
+#include "vnode.h"
+#include "glo.h"
+#include "scratchpad.h"
+
+int do_notify(void) {
+    printf("WCHODZE %d %d\n", m_in.m_lc_vfs_notify.fd, job_m_in.m_type);
+    int event = m_in.m_lc_vfs_notify.event;
+    if (event != NOTIFY_OPEN && event != NOTIFY_TRIOPEN &&
+        event != NOTIFY_CREATE && event != NOTIFY_MOVE)
+        return -EINVAL;
+
+    printf("POPRAWNY KOMUNIKAT\n");
+    struct filp* filp = get_filp(m_in.m_lc_vfs_notify.fd, VNODE_NONE);
+    
+    struct vnode* vnode = filp->filp_vno;
+    printf("MAM VNODE\n");
+    printf("MAM LOCKA %d\n", vnode->listeners_count);
+    
+    if (listeners + 1 > NR_NOTIFY) {
+        puts("JAHA");
+        return -ENONOTIFY;
+    }
+
+    listeners++;
+
+    vnode->listeners_count++;
+    printf("MALO LOCKOW %d\n", vnode->listeners_count);
+
+    scratch(fp).file.filp = filp;
+    suspend(FP_BLOCKED_ON_NOTIFY_OPEN);
+    return (SUSPEND);
+}
diff -rupNEZbB old/usr/src/minix/servers/vfs/open.c src/usr/src/minix/servers/vfs/open.c
--- old/usr/src/minix/servers/vfs/open.c	2022-06-11 09:31:08.215488928 +0200
+++ src/usr/src/minix/servers/vfs/open.c	2022-06-14 19:30:05.700008328 +0200
@@ -32,6 +32,7 @@ static char mode_map[] = {R_BIT, W_BIT,
 static struct vnode *new_node(struct lookup *resolve, int oflags,
 	mode_t bits);
 static int pipe_open(struct vnode *vp, mode_t bits, int oflags);
+static void wake_listeners(struct filp *filp);
 
 /*===========================================================================*
  *				do_open					     *
@@ -266,6 +267,9 @@ int common_open(char path[PATH_MAX], int
 	}
   }
 
+    if (r == OK && (oflags == 0)) {
+        wake_listeners(filp);
+    }
   unlock_filp(filp);
 
   /* If error, release inode. */
@@ -672,8 +676,8 @@ int do_close(void)
  *				close_fd				     *
  *===========================================================================*/
 int close_fd(rfp, fd_nr)
-struct fproc *rfp;
-int fd_nr;
+        struct fproc *rfp;
+        int fd_nr;
 {
 /* Perform the close(fd) system call. */
   register struct filp *rfilp;
@@ -711,3 +715,21 @@ int fd_nr;
 
   return(OK);
 }
+
+/*===========================================================================*
+ *				wake_listeners				     *
+ *===========================================================================*/
+void wake_listeners(filp)
+struct filp *filp;
+{
+  struct vnode* vnode = filp->filp_vno;
+
+  if (vnode->listeners_count > 0) {
+    printf("Listeners %d\n", vnode->listeners_count);  
+    int wakings = vnode->listeners_count;
+    release(vnode, VFS_NOTIFY, wakings);
+
+    vnode->listeners_count = 0;
+    puts("Wychodze z petli");
+  } // DEBUG
+}
\ No newline at end of file
diff -rupNEZbB old/usr/src/minix/servers/vfs/pipe.c src/usr/src/minix/servers/vfs/pipe.c
--- old/usr/src/minix/servers/vfs/pipe.c	2022-06-14 11:38:06.839122511 +0200
+++ src/usr/src/minix/servers/vfs/pipe.c	2022-06-14 19:28:40.475733173 +0200
@@ -301,13 +301,18 @@ void suspend(int why)
  * The SUSPEND pseudo error should be returned after calling suspend().
  */
 
-  if (why == FP_BLOCKED_ON_POPEN || why == FP_BLOCKED_ON_PIPE)
+  if (why == FP_BLOCKED_ON_POPEN || why == FP_BLOCKED_ON_PIPE || 
+  	why == FP_BLOCKED_ON_NOTIFY_OPEN)
 	/* #procs susp'ed on pipe*/
 	susp_count++;
 
   fp->fp_blocked_on = why;
+  if (why == FP_BLOCKED_ON_NOTIFY_OPEN)
+	puts("NOTIFY OPEN");
   assert(fp->fp_grant == GRANT_INVALID || !GRANT_VALID(fp->fp_grant));
   fp->fp_block_callnr = job_call_nr;
+  if (job_call_nr == VFS_NOTIFY)
+	puts("NOTIFY");
 }
 
 /*===========================================================================*
@@ -379,7 +384,8 @@ int count;			/* max number of processes
   register struct fproc *rp;
   struct filp *f;
   int selop;
-
+	if (op == VFS_NOTIFY)
+		puts("VFS_NOTIFY RELEASE");
   /* Trying to perform the call also includes SELECTing on it with that
    * operation.
    */
@@ -402,6 +408,13 @@ int count;			/* max number of processes
 
   /* Search the proc table. */
   for (rp = &fproc[0]; rp < &fproc[NR_PROCS] && count > 0; rp++) {
+	if (op == VFS_NOTIFY && rp->fp_blocked_on == FP_BLOCKED_ON_NOTIFY_OPEN) {
+		puts("?");
+		if (scratch(rp).file.filp->filp_vno != vp)
+			puts("KUPA");
+		else 
+			puts("GITUWA");
+	}
 	if (rp->fp_pid != PID_FREE && fp_is_blocked(rp) &&
 	    !(rp->fp_flags & FP_REVIVED) && rp->fp_block_callnr == op) {
 		/* Find the vnode. Depending on the reason the process was
@@ -416,7 +428,8 @@ int count;			/* max number of processes
 				continue;
 			if (rp->fp_filp[scratch(rp).file.fd_nr]->filp_vno != vp)
 				continue;
-		} else if (rp->fp_blocked_on == FP_BLOCKED_ON_PIPE) {
+		} else if (rp->fp_blocked_on == FP_BLOCKED_ON_PIPE || 
+			rp->fp_blocked_on == FP_BLOCKED_ON_NOTIFY_OPEN) {
 			if (scratch(rp).file.filp == NULL)
 				continue;
 			if (scratch(rp).file.filp->filp_vno != vp)
@@ -426,6 +439,8 @@ int count;			/* max number of processes
 
 		/* We found the vnode. Revive process. */
 		revive(rp->fp_endpoint, 0);
+		if (FP_BLOCKED_ON_NOTIFY_OPEN)
+			listeners--;
 		susp_count--;	/* keep track of who is suspended */
 		if(susp_count < 0)
 			panic("susp_count now negative: %d", susp_count);
@@ -447,10 +462,12 @@ void revive(endpoint_t proc_e, int retur
   struct fproc *rfp;
   int blocked_on;
   int fd_nr, slot;
-
   if (proc_e == NONE || isokendpt(proc_e, &slot) != OK) return;
 
   rfp = &fproc[slot];
+  if (rfp->fp_blocked_on == FP_BLOCKED_ON_NOTIFY_OPEN) {
+	  puts("GOod!");
+  }
   if (!fp_is_blocked(rfp) || (rfp->fp_flags & FP_REVIVED)) return;
 
   /* The 'reviving' flag only applies to pipes.  Processes waiting for TTY get
diff -rupNEZbB old/usr/src/minix/servers/vfs/table.c src/usr/src/minix/servers/vfs/table.c
--- old/usr/src/minix/servers/vfs/table.c	2022-06-07 20:57:36.093531325 +0200
+++ src/usr/src/minix/servers/vfs/table.c	2022-06-07 21:37:09.213181982 +0200
@@ -65,4 +65,5 @@ int (* const call_vec[NR_VFS_CALLS])(voi
 	CALL(VFS_COPYFD)	= do_copyfd,		/* copyfd(2) */
 	CALL(VFS_CHECKPERMS)	= do_checkperms,	/* checkperms(2) */
 	CALL(VFS_GETSYSINFO)	= do_getsysinfo,	/* getsysinfo(2) */
+	CALL(VFS_NOTIFY)	= do_notify,		/* notify() */
 };
diff -rupNEZbB old/usr/src/minix/servers/vfs/vnode.c src/usr/src/minix/servers/vfs/vnode.c
--- old/usr/src/minix/servers/vfs/vnode.c	2022-06-11 15:21:47.090169603 +0200
+++ src/usr/src/minix/servers/vfs/vnode.c	2022-06-11 22:58:52.421698688 +0200
@@ -145,6 +145,15 @@ void init_vnodes(void)
 	vp->v_fs_count = 0;
 	vp->v_mapfs_count = 0;
 	tll_init(&vp->v_lock);
+  if (cond_init(&vp->for_locker, NULL) != 0) panic("failed notify");
+  if (cond_init(&vp->for_listeners, NULL) != 0) panic("failed notify");
+  
+  if (mutex_init(&vp->notify_lock, NULL) != 0) panic("failed notify");
+  if (mutex_init(&vp->cascade_lock, NULL) != 0) panic("failed notify");
+
+  vp->listeners_count = 0;
+  vp->failed_listeners_count = 0;
+  vp->is_waking = 0;
   }
 }
 
diff -rupNEZbB old/usr/src/minix/servers/vfs/vnode.h src/usr/src/minix/servers/vfs/vnode.h
--- old/usr/src/minix/servers/vfs/vnode.h	2022-06-11 15:00:29.531852588 +0200
+++ src/usr/src/minix/servers/vfs/vnode.h	2022-06-11 22:58:56.889811314 +0200
@@ -20,6 +20,18 @@ EXTERN struct vnode {
   dev_t v_sdev;                 /* device number for special files */
   struct vmnt *v_vmnt;          /* vmnt object of the partition */
   tll_t v_lock;			/* three-level-lock */
+  
+  /* following are for do_notify() */
+  mutex_t notify_lock;  /* Main notify mutex. */
+  mutex_t cascade_lock;  /* Mutex for waking listeners. */
+
+  cond_t for_locker;    /* Wait for end of listeners waking */
+  cond_t for_listeners; /* Wait for a new event */
+
+  int listeners_count;      /* Number of event listeners */
+  int failed_listeners_count; /* Number of event listeners
+                                 that has failed condition */
+  int is_waking;
 } vnode[NR_VNODES];
 
 /* vnode lock types mapping */
diff -rupNEZbB old/usr/src/sys/sys/errno.h src/usr/src/sys/sys/errno.h
--- old/usr/src/sys/sys/errno.h	2022-06-07 20:58:38.543769000 +0200
+++ src/usr/src/sys/sys/errno.h	2022-06-07 21:37:42.474294372 +0200
@@ -172,7 +172,9 @@
 #define	ENOLINK		(_SIGN 95 )		/* Link has been severed */
 #define	EPROTO		(_SIGN 96 )		/* Protocol error */
 
-#define	ELAST		(_SIGN 96 )		/* Must equal largest errno */
+#define	ENONOTIFY		(_SIGN 97 )		/* No more notifications available */
+
+#define	ELAST		(_SIGN 97 )		/* Must equal largest errno */
 
 #if defined(_KERNEL) || defined(_KMEMUSER)
 /* pseudo-errors returned inside kernel to modify return to process */
diff -rupNEZbB old/usr/src/sys/sys/fcntl.h src/usr/src/sys/sys/fcntl.h
--- old/usr/src/sys/sys/fcntl.h	2022-06-07 20:58:52.252276209 +0200
+++ src/usr/src/sys/sys/fcntl.h	2022-06-07 21:37:50.746571523 +0200
@@ -301,6 +301,14 @@ struct flock {
 #define	AT_REMOVEDIR		0x800	/* Remove directory only */
 #endif
 
+/*
+ * Event flags used by notify()
+ */
+#define	NOTIFY_OPEN	0x00000001	/* file is opened */
+#define	NOTIFY_TRIOPEN	0x00000002	/* file is opened >= 3 times simultaneously */
+#define	NOTIFY_CREATE	0x00000004	/* file is created in the directory */
+#define	NOTIFY_MOVE	0x00000008	/* file is moved to the directory */
+
 
 #ifndef _KERNEL
 #include <sys/cdefs.h>
